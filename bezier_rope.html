<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Bezier Rope Demo</title>
  <style>
    html,body { height:100%; margin:0; background:#111; color:#ddd; font-family:system-ui, sans-serif; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

<script>
// -------------------- VECTOR HELPERS --------------------
function v(x=0,y=0){ return {x:x, y:y}; }
function add(a,b){ return {x: a.x + b.x, y: a.y + b.y}; }
function sub(a,b){ return {x: a.x - b.x, y: a.y - b.y}; }
function mul(a, s){ return {x: a.x * s, y: a.y * s}; }
function length(a){ return Math.hypot(a.x, a.y); }
function normalize(a){ const L = length(a) || 1; return {x: a.x / L, y: a.y / L}; }

// -------------------- BEZIER FORMULAS --------------------
// Evaluate cubic Bezier point at t in [0,1]
function bezierPoint(t, P0,P1,P2,P3){
  const u = 1 - t;
  const u3 = u*u*u;
  const u2t = 3 * u*u * t;
  const ut2 = 3 * u * t*t;
  const t3 = t*t*t;
  return {
    x: u3*P0.x + u2t*P1.x + ut2*P2.x + t3*P3.x,
    y: u3*P0.y + u2t*P1.y + ut2*P2.y + t3*P3.y
  };
}

// Tangent (direction) of Bezier at t
function bezierTangent(t, P0,P1,P2,P3){
  const u = 1 - t;
  const a = mul(sub(P1,P0), 3*u*u);
  const b = mul(sub(P2,P1), 6*u*t);
  const c = mul(sub(P3,P2), 3*t*t);
  return add(add(a,b),c);
}

// -------------------- CANVAS SETUP --------------------
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });
function resize(){
  const w = window.innerWidth, h = window.innerHeight;
  canvas.width = Math.round(w * devicePixelRatio);
  canvas.height = Math.round(h * devicePixelRatio);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
}
window.addEventListener('resize', resize);
resize();

// -------------------- CONTROL POINTS --------------------
const P0 = v(80, window.innerHeight - 80);    // left fixed endpoint
const P3 = v(window.innerWidth - 80, 80);     // right fixed endpoint

function makeDynamic(x,y){ return { pos: v(x,y), vel: v(0,0), target: v(x,y) }; }
const P1 = makeDynamic(window.innerWidth * 0.35, window.innerHeight * 0.5);
const P2 = makeDynamic(window.innerWidth * 0.65, window.innerHeight * 0.5);

// -------------------- PHYSICS (spring-damper) --------------------
let K = 400; // spring strength
let C = 40;  // damping
const mass = 1;

function physicsStep(body, dt){
  const diff = sub(body.pos, body.target);
  const springForce = mul(diff, -K / mass);
  const dampingForce = mul(body.vel, -C / mass);
  const acc = add(springForce, dampingForce);
  body.vel.x += acc.x * dt;
  body.vel.y += acc.y * dt;
  body.pos.x += body.vel.x * dt;
  body.pos.y += body.vel.y * dt;
}

// -------------------- MOUSE INPUT --------------------
let mouse = null;
canvas.addEventListener('mousemove', (e) => {
  mouse = { x: e.clientX, y: e.clientY };
  P1.target.x = mouse.x - 80;  P1.target.y = mouse.y + 40;
  P2.target.x = mouse.x + 80;  P2.target.y = mouse.y - 40;
});
canvas.addEventListener('mouseleave', () => { mouse = null; });

// allow dragging P1 or P2
let dragging = null;
canvas.addEventListener('mousedown', (e) => {
  const p = {x:e.clientX, y:e.clientY};
  const d1 = Math.hypot(P1.pos.x - p.x, P1.pos.y - p.y);
  const d2 = Math.hypot(P2.pos.x - p.x, P2.pos.y - p.y);
  if (d1 < 20) dragging = 'P1';
  else if (d2 < 20) dragging = 'P2';
});
window.addEventListener('mouseup', ()=> dragging = null);
window.addEventListener('mousemove', (e) => {
  if (!dragging) return;
  if (dragging === 'P1'){ P1.target.x = e.clientX; P1.target.y = e.clientY; }
  if (dragging === 'P2'){ P2.target.x = e.clientX; P2.target.y = e.clientY; }
});

// -------------------- ANIMATION LOOP --------------------
let last = performance.now();
function frame(now){
  const dt = Math.min((now - last) / 1000, 1/15);
  last = now;

  const steps = 2;
  const sdt = dt / steps;
  for(let i=0;i<steps;i++){
    physicsStep(P1, sdt);
    physicsStep(P2, sdt);
  }

  draw();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

// -------------------- DRAWING --------------------
function draw(){
  ctx.fillStyle = '#111';
  ctx.fillRect(0,0, window.innerWidth, window.innerHeight);

  const samples = 80;
  ctx.lineWidth = 3;
  ctx.strokeStyle = '#7FC7FF';
  ctx.beginPath();
  for(let i=0;i<=samples;i++){
    const t = i / samples;
    const bp = bezierPoint(t, P0, P1.pos, P2.pos, P3);
    if (i === 0) ctx.moveTo(bp.x, bp.y);
    else ctx.lineTo(bp.x, bp.y);
  }
  ctx.stroke();

  const tangentLen = 40;
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#FFD27A';
  for(let i=0;i<=8;i++){
    const t = i / 8;
    const bp = bezierPoint(t, P0, P1.pos, P2.pos, P3);
    const bt = bezierTangent(t, P0, P1.pos, P2.pos, P3);
    const n = normalize(bt);
    const a = add(bp, mul(n, tangentLen*0.5));
    const b = add(bp, mul(n, -tangentLen*0.5));
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  }

  ctx.lineWidth = 1;
  ctx.strokeStyle = '#444';
  ctx.beginPath();
  ctx.moveTo(P0.x,P0.y);
  ctx.lineTo(P1.pos.x,P1.pos.y);
  ctx.lineTo(P2.pos.x,P2.pos.y);
  ctx.lineTo(P3.x,P3.y);
  ctx.stroke();

  function drawPoint(p, color, r=6){
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(p.x,p.y,r,0,Math.PI*2);
    ctx.fill();
  }
  drawPoint(P0, '#E8E8E8', 6);
  drawPoint(P1.pos, '#FF6F85', 8);
  drawPoint(P2.pos, '#6FFFB7', 8);
  drawPoint(P3, '#E8E8E8', 6);
}
</script>
</body>
</html>
